diff --git a/configure.ac b/configure.ac
index 19d8548..204cee0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -162,6 +162,11 @@ AC_CHECK_HEADERS([langinfo.h],
 		[AM_CONDITIONAL([HAVE_LANGINFO], [true])],
 		[AM_CONDITIONAL([HAVE_LANGINFO], [false])])
 
+AC_CHECK_HEADERS([linux/blkzoned_api.h], [], [], [
+#ifdef HAVE_BLKZONED_API_H
+#include <linux/blkzoned_api.h>
+#endif
+])
 
 AC_CHECK_DECLS([_NL_TIME_WEEK_1STDAY],[],[],[[#include <langinfo.h>]])
 
diff --git a/include/c.h b/include/c.h
index d50e4c4..2a317eb 100644
--- a/include/c.h
+++ b/include/c.h
@@ -6,19 +6,23 @@
 #define UTIL_LINUX_C_H
 
 #include <limits.h>
+#include <stddef.h>
 #include <stdint.h>
 #include <stdio.h>
+#include <unistd.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
 
+#include <assert.h>
+
 #ifdef HAVE_ERR_H
 # include <err.h>
 #endif
 
 /*
- * Compiler specific stuff
+ * Compiler-specific stuff
  */
 #ifndef __GNUC_PREREQ
 # if defined __GNUC__ && defined __GNUC_MINOR__
@@ -35,7 +39,7 @@
 # define __must_be_array(a) \
 	UL_BUILD_BUG_ON_ZERO(__builtin_types_compatible_p(__typeof__(a), __typeof__(&a[0])))
 
-# define ignore_result(x) ({ \
+# define ignore_result(x) __extension__ ({ \
 	__typeof__(x) __dummy __attribute__((__unused__)) = (x); (void) __dummy; \
 })
 
@@ -50,7 +54,7 @@
  */
 #ifndef __ul_alloc_size
 # if __GNUC_PREREQ (4, 3)
-#  define __ul_alloc_size(s) __attribute__((alloc_size(s)))
+#  define __ul_alloc_size(s) __attribute__((alloc_size(s), warn_unused_result))
 # else
 #  define __ul_alloc_size(s)
 # endif
@@ -58,18 +62,19 @@
 
 #ifndef __ul_calloc_size
 # if __GNUC_PREREQ (4, 3)
-#  define __ul_calloc_size(n, s) __attribute__((alloc_size(n, s)))
+#  define __ul_calloc_size(n, s) __attribute__((alloc_size(n, s), warn_unused_result))
 # else
 #  define __ul_calloc_size(n, s)
 # endif
 #endif
 
-/* Force a compilation error if condition is true, but also produce a
+/*
+ * Force a compilation error if condition is true, but also produce a
  * result (of value 0 and type size_t), so the expression can be used
- * e.g. in a structure initializer (or where-ever else comma expressions
+ * e.g. in a structure initializer (or wherever else comma expressions
  * aren't permitted).
  */
-#define UL_BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))
+#define UL_BUILD_BUG_ON_ZERO(e) __extension__ (sizeof(struct { int:-!!(e); }))
 #define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); }))
 
 #ifndef ARRAY_SIZE
@@ -89,7 +94,7 @@
 #endif
 
 #ifndef min
-# define min(x, y) ({				\
+# define min(x, y) __extension__ ({		\
 	__typeof__(x) _min1 = (x);		\
 	__typeof__(y) _min2 = (y);		\
 	(void) (&_min1 == &_min2);		\
@@ -97,13 +102,31 @@
 #endif
 
 #ifndef max
-# define max(x, y) ({				\
+# define max(x, y) __extension__ ({		\
 	__typeof__(x) _max1 = (x);		\
 	__typeof__(y) _max2 = (y);		\
 	(void) (&_max1 == &_max2);		\
 	_max1 > _max2 ? _max1 : _max2; })
 #endif
 
+#ifndef cmp_numbers
+# define cmp_numbers(x, y) __extension__ ({	\
+	__typeof__(x) _a = (x);			\
+	__typeof__(y) _b = (y);			\
+	(void) (&_a == &_b);			\
+	_a == _b ? 0 : _a > _b ? 1 : -1; })
+#endif
+
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+#ifndef container_of
+#define container_of(ptr, type, member) __extension__ ({	 \
+	const __typeof__( ((type *)0)->member ) *__mptr = (ptr); \
+	(type *)( (char *)__mptr - offsetof(type,member) );})
+#endif
+
 #ifndef HAVE_PROGRAM_INVOCATION_SHORT_NAME
 # ifdef HAVE___PROGNAME
 extern char *__progname;
@@ -153,7 +176,7 @@ errmsg(char doexit, int excode, char adderr, const char *fmt, ...)
 			fprintf(stderr, ": ");
 	}
 	if (adderr)
-		fprintf(stderr, "%s", strerror(errno));
+		fprintf(stderr, "%m");
 	fprintf(stderr, "\n");
 	if (doexit)
 		exit(excode);
@@ -199,10 +222,24 @@ static inline int dirfd(DIR *d)
  * Fallback defines for old versions of glibc
  */
 #include <fcntl.h>
+
+#ifdef O_CLOEXEC
+#define UL_CLOEXECSTR	"e"
+#else
+#define UL_CLOEXECSTR	""
+#endif
+
 #ifndef O_CLOEXEC
 #define O_CLOEXEC 0
 #endif
 
+#ifdef __FreeBSD_kernel__
+#ifndef F_DUPFD_CLOEXEC
+#define F_DUPFD_CLOEXEC	17	/* Like F_DUPFD, but FD_CLOEXEC is set */
+#endif
+#endif
+
+
 #ifndef AI_ADDRCONFIG
 #define AI_ADDRCONFIG 0x0020
 #endif
@@ -212,6 +249,59 @@ static inline int dirfd(DIR *d)
 #endif
 
 /*
+ * MAXHOSTNAMELEN replacement
+ */
+static inline size_t get_hostname_max(void)
+{
+	long len = sysconf(_SC_HOST_NAME_MAX);
+
+	if (0 < len)
+		return len;
+
+#ifdef MAXHOSTNAMELEN
+	return MAXHOSTNAMELEN;
+#elif HOST_NAME_MAX
+	return HOST_NAME_MAX;
+#endif
+	return 64;
+}
+
+/*
+ * The usleep function was marked obsolete in POSIX.1-2001 and was removed
+ * in POSIX.1-2008.  It was replaced with nanosleep() that provides more
+ * advantages (like no interaction with signals and other timer functions).
+ */
+#include <time.h>
+
+static inline int xusleep(useconds_t usec)
+{
+#ifdef HAVE_NANOSLEEP
+	struct timespec waittime = {
+		.tv_sec   =  usec / 1000000L,
+		.tv_nsec  = (usec % 1000000L) * 1000
+	};
+	return nanosleep(&waittime, NULL);
+#elif defined(HAVE_USLEEP)
+	return usleep(usec);
+#else
+# error	"System with usleep() or nanosleep() required!"
+#endif
+}
+
+/*
+ * Constant strings for usage() functions. For more info see
+ * Documentation/howto-usage-function.txt and disk-utils/delpart.c
+ */
+#define USAGE_HEADER     _("\nUsage:\n")
+#define USAGE_OPTIONS    _("\nOptions:\n")
+#define USAGE_SEPARATOR    "\n"
+#define USAGE_HELP       _(" -h, --help     display this help and exit\n")
+#define USAGE_VERSION    _(" -V, --version  output version information and exit\n")
+#define USAGE_MAN_TAIL(_man)   _("\nFor more details see %s.\n"), _man
+
+#define UTIL_LINUX_VERSION _("%s from %s\n"), program_invocation_short_name, PACKAGE_STRING
+
+/*
  * scanf modifiers for "strings allocation"
  */
 #ifdef HAVE_SCANF_MS_MODIFIER
@@ -220,4 +310,40 @@ static inline int dirfd(DIR *d)
 #define UL_SCNsA	"%as"
 #endif
 
+/*
+ * seek stuff
+ */
+#ifndef SEEK_DATA
+# define SEEK_DATA	3
+#endif
+#ifndef SEEK_HOLE
+# define SEEK_HOLE	4
+#endif
+
+
+/*
+ * Macros to convert #define'itions to strings, for example
+ * #define XYXXY 42
+ * printf ("%s=%s\n", stringify(XYXXY), stringify_value(XYXXY));
+ */
+#define stringify_value(s) stringify(s)
+#define stringify(s) #s
+
+/*
+ * UL_ASAN_BLACKLIST is a macro to tell AddressSanitizer (a compile-time
+ * instrumentation shipped with Clang and GCC) to not instrument the
+ * annotated function.  Furthermore, it will prevent the compiler from
+ * inlining the function because inlining currently breaks the blacklisting
+ * mechanism of AddressSanitizer.
+ */
+#if defined(__has_feature)
+# if __has_feature(address_sanitizer)
+#  define UL_ASAN_BLACKLIST __attribute__((noinline)) __attribute__((no_sanitize_memory)) __attribute__((no_sanitize_address))
+# else
+#  define UL_ASAN_BLACKLIST	/* nothing */
+# endif
+#else
+# define UL_ASAN_BLACKLIST	/* nothing */
+#endif
+
 #endif /* UTIL_LINUX_C_H */
diff --git a/include/crc64.h b/include/crc64.h
new file mode 100644
index 0000000..40475d5
--- /dev/null
+++ b/include/crc64.h
@@ -0,0 +1,9 @@
+#ifndef UTIL_LINUX_CRC64_H
+#define UTIL_LINUX_CRC64_H
+
+#include <sys/types.h>
+#include <stdint.h>
+
+extern uint64_t crc64(uint64_t seed, const unsigned char *data, size_t len);
+
+#endif
diff --git a/include/strutils.h b/include/strutils.h
index 54463bc..4fbb560 100644
--- a/include/strutils.h
+++ b/include/strutils.h
@@ -9,6 +9,8 @@ extern int strtosize(const char *str, uintmax_t *res);
 extern long strtol_or_err(const char *str, const char *errmesg);
 extern long long strtoll_or_err(const char *str, const char *errmesg);
 extern unsigned long strtoul_or_err(const char *str, const char *errmesg);
+extern uint64_t strtou64_or_error(const char *str, const char *errmesg);
+extern uint64_t strtou64_base_or_err(int base, const char *str, const char *errmesg);
 
 extern int isdigit_string(const char *str);
 
diff --git a/lib/crc64.c b/lib/crc64.c
new file mode 100644
index 0000000..0be78e6
--- /dev/null
+++ b/lib/crc64.c
@@ -0,0 +1,109 @@
+#include "crc64.h"
+
+static const uint64_t crc64_tab[256] = {
+	0x0000000000000000ULL, 0x42F0E1EBA9EA3693ULL, 0x85E1C3D753D46D26ULL,
+	0xC711223CFA3E5BB5ULL, 0x493366450E42ECDFULL, 0x0BC387AEA7A8DA4CULL,
+	0xCCD2A5925D9681F9ULL, 0x8E224479F47CB76AULL, 0x9266CC8A1C85D9BEULL,
+	0xD0962D61B56FEF2DULL, 0x17870F5D4F51B498ULL, 0x5577EEB6E6BB820BULL,
+	0xDB55AACF12C73561ULL, 0x99A54B24BB2D03F2ULL, 0x5EB4691841135847ULL,
+	0x1C4488F3E8F96ED4ULL, 0x663D78FF90E185EFULL, 0x24CD9914390BB37CULL,
+	0xE3DCBB28C335E8C9ULL, 0xA12C5AC36ADFDE5AULL, 0x2F0E1EBA9EA36930ULL,
+	0x6DFEFF5137495FA3ULL, 0xAAEFDD6DCD770416ULL, 0xE81F3C86649D3285ULL,
+	0xF45BB4758C645C51ULL, 0xB6AB559E258E6AC2ULL, 0x71BA77A2DFB03177ULL,
+	0x334A9649765A07E4ULL, 0xBD68D2308226B08EULL, 0xFF9833DB2BCC861DULL,
+	0x388911E7D1F2DDA8ULL, 0x7A79F00C7818EB3BULL, 0xCC7AF1FF21C30BDEULL,
+	0x8E8A101488293D4DULL, 0x499B3228721766F8ULL, 0x0B6BD3C3DBFD506BULL,
+	0x854997BA2F81E701ULL, 0xC7B97651866BD192ULL, 0x00A8546D7C558A27ULL,
+	0x4258B586D5BFBCB4ULL, 0x5E1C3D753D46D260ULL, 0x1CECDC9E94ACE4F3ULL,
+	0xDBFDFEA26E92BF46ULL, 0x990D1F49C77889D5ULL, 0x172F5B3033043EBFULL,
+	0x55DFBADB9AEE082CULL, 0x92CE98E760D05399ULL, 0xD03E790CC93A650AULL,
+	0xAA478900B1228E31ULL, 0xE8B768EB18C8B8A2ULL, 0x2FA64AD7E2F6E317ULL,
+	0x6D56AB3C4B1CD584ULL, 0xE374EF45BF6062EEULL, 0xA1840EAE168A547DULL,
+	0x66952C92ECB40FC8ULL, 0x2465CD79455E395BULL, 0x3821458AADA7578FULL,
+	0x7AD1A461044D611CULL, 0xBDC0865DFE733AA9ULL, 0xFF3067B657990C3AULL,
+	0x711223CFA3E5BB50ULL, 0x33E2C2240A0F8DC3ULL, 0xF4F3E018F031D676ULL,
+	0xB60301F359DBE0E5ULL, 0xDA050215EA6C212FULL, 0x98F5E3FE438617BCULL,
+	0x5FE4C1C2B9B84C09ULL, 0x1D14202910527A9AULL, 0x93366450E42ECDF0ULL,
+	0xD1C685BB4DC4FB63ULL, 0x16D7A787B7FAA0D6ULL, 0x5427466C1E109645ULL,
+	0x4863CE9FF6E9F891ULL, 0x0A932F745F03CE02ULL, 0xCD820D48A53D95B7ULL,
+	0x8F72ECA30CD7A324ULL, 0x0150A8DAF8AB144EULL, 0x43A04931514122DDULL,
+	0x84B16B0DAB7F7968ULL, 0xC6418AE602954FFBULL, 0xBC387AEA7A8DA4C0ULL,
+	0xFEC89B01D3679253ULL, 0x39D9B93D2959C9E6ULL, 0x7B2958D680B3FF75ULL,
+	0xF50B1CAF74CF481FULL, 0xB7FBFD44DD257E8CULL, 0x70EADF78271B2539ULL,
+	0x321A3E938EF113AAULL, 0x2E5EB66066087D7EULL, 0x6CAE578BCFE24BEDULL,
+	0xABBF75B735DC1058ULL, 0xE94F945C9C3626CBULL, 0x676DD025684A91A1ULL,
+	0x259D31CEC1A0A732ULL, 0xE28C13F23B9EFC87ULL, 0xA07CF2199274CA14ULL,
+	0x167FF3EACBAF2AF1ULL, 0x548F120162451C62ULL, 0x939E303D987B47D7ULL,
+	0xD16ED1D631917144ULL, 0x5F4C95AFC5EDC62EULL, 0x1DBC74446C07F0BDULL,
+	0xDAAD56789639AB08ULL, 0x985DB7933FD39D9BULL, 0x84193F60D72AF34FULL,
+	0xC6E9DE8B7EC0C5DCULL, 0x01F8FCB784FE9E69ULL, 0x43081D5C2D14A8FAULL,
+	0xCD2A5925D9681F90ULL, 0x8FDAB8CE70822903ULL, 0x48CB9AF28ABC72B6ULL,
+	0x0A3B7B1923564425ULL, 0x70428B155B4EAF1EULL, 0x32B26AFEF2A4998DULL,
+	0xF5A348C2089AC238ULL, 0xB753A929A170F4ABULL, 0x3971ED50550C43C1ULL,
+	0x7B810CBBFCE67552ULL, 0xBC902E8706D82EE7ULL, 0xFE60CF6CAF321874ULL,
+	0xE224479F47CB76A0ULL, 0xA0D4A674EE214033ULL, 0x67C58448141F1B86ULL,
+	0x253565A3BDF52D15ULL, 0xAB1721DA49899A7FULL, 0xE9E7C031E063ACECULL,
+	0x2EF6E20D1A5DF759ULL, 0x6C0603E6B3B7C1CAULL, 0xF6FAE5C07D3274CDULL,
+	0xB40A042BD4D8425EULL, 0x731B26172EE619EBULL, 0x31EBC7FC870C2F78ULL,
+	0xBFC9838573709812ULL, 0xFD39626EDA9AAE81ULL, 0x3A28405220A4F534ULL,
+	0x78D8A1B9894EC3A7ULL, 0x649C294A61B7AD73ULL, 0x266CC8A1C85D9BE0ULL,
+	0xE17DEA9D3263C055ULL, 0xA38D0B769B89F6C6ULL, 0x2DAF4F0F6FF541ACULL,
+	0x6F5FAEE4C61F773FULL, 0xA84E8CD83C212C8AULL, 0xEABE6D3395CB1A19ULL,
+	0x90C79D3FEDD3F122ULL, 0xD2377CD44439C7B1ULL, 0x15265EE8BE079C04ULL,
+	0x57D6BF0317EDAA97ULL, 0xD9F4FB7AE3911DFDULL, 0x9B041A914A7B2B6EULL,
+	0x5C1538ADB04570DBULL, 0x1EE5D94619AF4648ULL, 0x02A151B5F156289CULL,
+	0x4051B05E58BC1E0FULL, 0x87409262A28245BAULL, 0xC5B073890B687329ULL,
+	0x4B9237F0FF14C443ULL, 0x0962D61B56FEF2D0ULL, 0xCE73F427ACC0A965ULL,
+	0x8C8315CC052A9FF6ULL, 0x3A80143F5CF17F13ULL, 0x7870F5D4F51B4980ULL,
+	0xBF61D7E80F251235ULL, 0xFD913603A6CF24A6ULL, 0x73B3727A52B393CCULL,
+	0x31439391FB59A55FULL, 0xF652B1AD0167FEEAULL, 0xB4A25046A88DC879ULL,
+	0xA8E6D8B54074A6ADULL, 0xEA16395EE99E903EULL, 0x2D071B6213A0CB8BULL,
+	0x6FF7FA89BA4AFD18ULL, 0xE1D5BEF04E364A72ULL, 0xA3255F1BE7DC7CE1ULL,
+	0x64347D271DE22754ULL, 0x26C49CCCB40811C7ULL, 0x5CBD6CC0CC10FAFCULL,
+	0x1E4D8D2B65FACC6FULL, 0xD95CAF179FC497DAULL, 0x9BAC4EFC362EA149ULL,
+	0x158E0A85C2521623ULL, 0x577EEB6E6BB820B0ULL, 0x906FC95291867B05ULL,
+	0xD29F28B9386C4D96ULL, 0xCEDBA04AD0952342ULL, 0x8C2B41A1797F15D1ULL,
+	0x4B3A639D83414E64ULL, 0x09CA82762AAB78F7ULL, 0x87E8C60FDED7CF9DULL,
+	0xC51827E4773DF90EULL, 0x020905D88D03A2BBULL, 0x40F9E43324E99428ULL,
+	0x2CFFE7D5975E55E2ULL, 0x6E0F063E3EB46371ULL, 0xA91E2402C48A38C4ULL,
+	0xEBEEC5E96D600E57ULL, 0x65CC8190991CB93DULL, 0x273C607B30F68FAEULL,
+	0xE02D4247CAC8D41BULL, 0xA2DDA3AC6322E288ULL, 0xBE992B5F8BDB8C5CULL,
+	0xFC69CAB42231BACFULL, 0x3B78E888D80FE17AULL, 0x7988096371E5D7E9ULL,
+	0xF7AA4D1A85996083ULL, 0xB55AACF12C735610ULL, 0x724B8ECDD64D0DA5ULL,
+	0x30BB6F267FA73B36ULL, 0x4AC29F2A07BFD00DULL, 0x08327EC1AE55E69EULL,
+	0xCF235CFD546BBD2BULL, 0x8DD3BD16FD818BB8ULL, 0x03F1F96F09FD3CD2ULL,
+	0x41011884A0170A41ULL, 0x86103AB85A2951F4ULL, 0xC4E0DB53F3C36767ULL,
+	0xD8A453A01B3A09B3ULL, 0x9A54B24BB2D03F20ULL, 0x5D45907748EE6495ULL,
+	0x1FB5719CE1045206ULL, 0x919735E51578E56CULL, 0xD367D40EBC92D3FFULL,
+	0x1476F63246AC884AULL, 0x568617D9EF46BED9ULL, 0xE085162AB69D5E3CULL,
+	0xA275F7C11F7768AFULL, 0x6564D5FDE549331AULL, 0x279434164CA30589ULL,
+	0xA9B6706FB8DFB2E3ULL, 0xEB46918411358470ULL, 0x2C57B3B8EB0BDFC5ULL,
+	0x6EA7525342E1E956ULL, 0x72E3DAA0AA188782ULL, 0x30133B4B03F2B111ULL,
+	0xF7021977F9CCEAA4ULL, 0xB5F2F89C5026DC37ULL, 0x3BD0BCE5A45A6B5DULL,
+	0x79205D0E0DB05DCEULL, 0xBE317F32F78E067BULL, 0xFCC19ED95E6430E8ULL,
+	0x86B86ED5267CDBD3ULL, 0xC4488F3E8F96ED40ULL, 0x0359AD0275A8B6F5ULL,
+	0x41A94CE9DC428066ULL, 0xCF8B0890283E370CULL, 0x8D7BE97B81D4019FULL,
+	0x4A6ACB477BEA5A2AULL, 0x089A2AACD2006CB9ULL, 0x14DEA25F3AF9026DULL,
+	0x562E43B4931334FEULL, 0x913F6188692D6F4BULL, 0xD3CF8063C0C759D8ULL,
+	0x5DEDC41A34BBEEB2ULL, 0x1F1D25F19D51D821ULL, 0xD80C07CD676F8394ULL,
+	0x9AFCE626CE85B507ULL
+};
+
+/*
+ * This a generic crc64() function, it takes seed as an argument,
+ * and does __not__ xor at the end. Then individual users can do
+ * whatever they need.
+ */
+uint64_t crc64(uint64_t seed, const unsigned char *data, size_t len)
+{
+	uint64_t crc = seed;
+
+	while (len) {
+		int i = ((int) (crc >> 56) ^ *data++) & 0xFF;
+		crc = crc64_tab[i] ^ (crc << 8);
+		len--;
+	}
+
+	return crc;
+}
+
diff --git a/lib/strutils.c b/lib/strutils.c
index ccda6fd..d113569 100644
--- a/lib/strutils.c
+++ b/lib/strutils.c
@@ -249,6 +249,32 @@ err:
 	return 0;
 }
 
+uint64_t strtou64_base_or_err(int base, const char *str, const char *errmesg)
+{
+	uintmax_t num;
+	char *end = NULL;
+
+	errno = 0;
+	if (str == NULL || *str == '\0')
+		goto err;
+	num = strtoumax(str, &end, base);
+
+	if (errno || str == end || (end && *end))
+		goto err;
+
+	return num;
+err:
+	if (errno == ERANGE)
+		err(EXIT_FAILURE, "%s: '%s'", errmesg, str);
+
+	errx(EXIT_FAILURE, "%s: '%s'", errmesg, str);
+}
+
+uint64_t strtou64_or_error(const char *str, const char *errmesg)
+{
+	return strtou64_base_or_err(10, str, errmesg);
+}
+
 /*
  * Converts stat->st_mode to ls(1)-like mode string. The size of "str" must
  * be 10 bytes.
diff --git a/libblkid/src/Makefile.am b/libblkid/src/Makefile.am
index 543f2f6..c40c4ed 100644
--- a/libblkid/src/Makefile.am
+++ b/libblkid/src/Makefile.am
@@ -27,6 +27,7 @@ libblkid_la_SOURCES = cache.c dev.c devname.c devno.c getsize.c llseek.c  \
 		     $(top_srcdir)/lib/canonicalize.c \
 		     $(top_srcdir)/lib/md5.c \
 		     $(top_srcdir)/lib/crc32.c \
+		     $(top_srcdir)/lib/crc64.c \
 		     $(top_srcdir)/include/list.h \
 		     $(top_srcdir)/lib/env.c \
 		     $(top_srcdir)/lib/strutils.c \
diff --git a/libblkid/src/superblocks/Makefile.am b/libblkid/src/superblocks/Makefile.am
index 1501fab..137011a 100644
--- a/libblkid/src/superblocks/Makefile.am
+++ b/libblkid/src/superblocks/Makefile.am
@@ -41,6 +41,7 @@ libblkid_superblocks_la_SOURCES = \
 			sysv.c \
 			btrfs.c \
 			lvm.c \
+			zdm.c \
 			zfs.c \
 			ubifs.c \
 			bfs.c \
diff --git a/libblkid/src/superblocks/superblocks.c b/libblkid/src/superblocks/superblocks.c
index 8a0edaa..f7c7c71 100644
--- a/libblkid/src/superblocks/superblocks.c
+++ b/libblkid/src/superblocks/superblocks.c
@@ -97,6 +97,7 @@ static const struct blkid_idinfo *idinfos[] =
 	&snapcow_idinfo,
 	&luks_idinfo,
 	&vmfs_volume_idinfo,
+	&zdm_idinfo,
 
 	/* Filesystems */
 	&vfat_idinfo,
diff --git a/libblkid/src/superblocks/superblocks.h b/libblkid/src/superblocks/superblocks.h
index a79d7cb..0511589 100644
--- a/libblkid/src/superblocks/superblocks.h
+++ b/libblkid/src/superblocks/superblocks.h
@@ -49,6 +49,7 @@ extern const struct blkid_idinfo ufs_idinfo;
 extern const struct blkid_idinfo hpfs_idinfo;
 extern const struct blkid_idinfo lvm2_idinfo;
 extern const struct blkid_idinfo lvm1_idinfo;
+extern const struct blkid_idinfo zdm_idinfo;
 extern const struct blkid_idinfo snapcow_idinfo;
 extern const struct blkid_idinfo luks_idinfo;
 extern const struct blkid_idinfo highpoint37x_idinfo;
diff --git a/libblkid/src/superblocks/zdm.c b/libblkid/src/superblocks/zdm.c
new file mode 100644
index 0000000..30fa892
--- /dev/null
+++ b/libblkid/src/superblocks/zdm.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2015 Shaun Tancheff <shaun@tancheff.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ *
+ * Based on code fragments from zdm-tools
+ */
+
+#include <stddef.h>
+#include <stdio.h>
+#include <uuid/uuid.h>
+
+#include "superblocks.h"
+#include "crc64.h"
+
+typedef uint8_t      u8;
+typedef uint32_t    u32;
+typedef uint64_t    u64;
+
+static const char zdm_magic[] = {
+	0x7a, 0x6f, 0x6e, 0x65, 0x63, 0x44, 0x45, 0x56,
+	0x82, 0x65, 0xf5, 0x7f, 0x48, 0xba, 0x6d, 0x81
+};
+
+struct zdm_super_block {
+	u64 crc64;
+	u8  magic[ARRAY_SIZE(zdm_magic)];
+	uuid_t  uuid;
+	u32 version;     /* 0xMMMMmmpt */
+	u64 sect_start;
+	u64 sect_size;
+	u32 mz_metadata_zones;     /* 3 (default) */
+	u32 mz_over_provision;     /* 5 (minimum) */
+	u64 zdm_blocks;  /* 0 -> <zdm_blocks> for dmsetup table entry */
+	u32 discard;     /* if discard support is enabled */
+	u32 disk_type;   /* HA | HM */
+	u32 zac_zbc;     /* if ZAC / ZBC is supported on backing device */
+	char label[64];
+};
+typedef struct zdm_super_block zdm_super_block_t;
+
+static uint64_t zdm_crc64(zdm_super_block_t *sblk)
+{
+	u64 icrc = sblk->crc64;
+	unsigned char *data = (unsigned char *) sblk;
+	size_t sz = sizeof(*sblk);
+	u64 calc;
+
+	sblk->crc64 = 0ul;
+	calc = crc64(0xFFFFFFFFFFFFFFFFULL, data, sz) ^ 0xFFFFFFFFFFFFFFFFULL;
+	sblk->crc64 = icrc;
+
+	return calc;
+}
+
+#ifndef BLKID_PROBE_NONE
+#define BLKID_PROBE_NONE -1
+#endif
+
+#ifndef BLKID_PROBE_OK
+#define BLKID_PROBE_OK 0
+#endif
+
+static int probe_zdm (blkid_probe pr, const struct blkid_idmag *mag)
+{
+	zdm_super_block_t *sblk;
+
+	sblk = blkid_probe_get_sb(pr, mag, struct zdm_super_block);
+	if (!sblk)
+		return errno ? -errno : BLKID_PROBE_NONE;
+
+	if (zdm_crc64(sblk) != le64_to_cpu(sblk->crc64))
+		return BLKID_PROBE_NONE;
+
+	if (blkid_probe_set_uuid(pr, sblk->uuid) < 0)
+		return BLKID_PROBE_NONE;
+
+	return BLKID_PROBE_OK;
+}
+
+const struct blkid_idinfo zdm_idinfo =
+{
+	.name		= "zdm",
+	.usage		= BLKID_USAGE_OTHER,
+	.probefunc	= probe_zdm,
+	.minsz		= 1 << 12,
+	.magics		=
+	{
+		{
+		  .magic = zdm_magic,
+		  .len   = sizeof(zdm_magic),
+		  .kboff = 0,
+		  .sboff = offsetof(struct zdm_super_block, magic)
+		} ,
+		{ NULL }
+	}
+};
diff --git a/sys-utils/Makefile.am b/sys-utils/Makefile.am
index feb5888..7d94c2a 100644
--- a/sys-utils/Makefile.am
+++ b/sys-utils/Makefile.am
@@ -10,12 +10,13 @@ dist_man_MANS = flock.1 ipcrm.1 ipcs.1 ipcmk.1 renice.1 setsid.1 \
 
 if LINUX
 bin_PROGRAMS += dmesg
-sbin_PROGRAMS += ctrlaltdel fsfreeze fstrim
+sbin_PROGRAMS += ctrlaltdel fsfreeze fstrim blkreport blkzonecmd
 usrbin_exec_PROGRAMS += cytune setarch
 usrsbin_exec_PROGRAMS += ldattach tunelp rtcwake
 
 dist_man_MANS += dmesg.1 ctrlaltdel.8 cytune.8 setarch.8 \
-		ldattach.8 tunelp.8 rtcwake.8 fsfreeze.8 fstrim.8
+		ldattach.8 tunelp.8 rtcwake.8 fsfreeze.8 fstrim.8 \
+		blkreport.8 blkzonecmd.8
 
 if HAVE_CPU_SET_T
 usrbin_exec_PROGRAMS += lscpu
@@ -28,6 +29,8 @@ endif
 cytune_SOURCES = cytune.c cyclades.h
 tunelp_SOURCES = tunelp.c lp.h
 fstrim_SOURCES = fstrim.c $(top_srcdir)/lib/strutils.c
+blkzonecmd_SOURCES = blkzonecmd.c $(top_srcdir)/lib/strutils.c
+blkreport_SOURCES = blkreport.c $(top_srcdir)/lib/strutils.c
 rtcwake_SOURCES = rtcwake.c $(top_srcdir)/lib/strutils.c
 dmesg_SOURCES = dmesg.c $(top_srcdir)/lib/strutils.c
 
diff --git a/sys-utils/blkreport.8 b/sys-utils/blkreport.8
new file mode 100644
index 0000000..05f1d19
--- /dev/null
+++ b/sys-utils/blkreport.8
@@ -0,0 +1,95 @@
+.TH BLKREPORT 5 "March 2016" "util-linux" "System Administration"
+.SH NAME
+blkreport \- report zones on a device
+.SH SYNOPSIS
+.B blkreport
+[options]
+.RB [ \-o
+.IR offset ]
+.RB [ \-l
+.IR report length ]
+.I device
+.SH DESCRIPTION
+.B blkreport
+is used to report device zone information.  This is useful for
+zoned devices that support the ZAC or ZBC command set.
+Unlike
+.BR sg_rep_zones (8) ,
+this command is can be used on any block device.
+.PP
+By default,
+.B blkreport
+will report from the start of the block device upto 512k bytes of the
+zone report (~8160 zones].  Options may be used to modify
+this behavior based on the starting zone or size of the report,
+as explained below.
+.PP
+The
+.I device
+argument is the pathname of the block device.
+.PP
+.SH OPTIONS
+The
+.I offset
+and
+.I length
+arguments may be followed by the multiplicative suffixes KiB (=1024),
+MiB (=1024*1024), and so on for GiB, TiB, PiB, EiB, ZiB and YiB (the "iB" is
+optional, e.g., "K" has the same meaning as "KiB") or the suffixes
+KB (=1000), MB (=1000*1000), and so on for GB, TB, PB, EB, ZB and YB.
+.TP
+.BR \-o , " \-\-offset \fIoffset"
+Byte offset into the device from which to start discarding.  The provided value
+will be aligned to the device sector size.  The default value is zero.
+.TP
+.BR \-l , " \-\-length \fIlength"
+The number of bytes to allocate for the report from the block device.
+The provided value will be aligned to the device sector size.
+If the specified value will be limited to the range of 512 bytes to 512 k-bytes.
+.TP
+.BR \-a , " \-\-ata"
+Issue ATA passthrough commands to the connected device. This option is to
+enable retrieving zone reports from SATA devices connected via SAS HBA's
+which have old firmware and will not translate ZBC commands to ZAC commands
+internally.
+Note that the resulting report will be little-endian and should be properly
+detected by
+.B blkreport.
+.TP
+.BR \-r , " \-\-option"
+Zoned devices support various reports. The default report lists all zones,
+however more specific reports can be specified. Available reports are:
+.BR 0 \- non seq. and reset (default)
+.BR 1 \- empty
+.BR 2 \- open implicit
+.BR 3 \- open explicit
+.BR 4 \- closed
+.BR 5 \- full
+.BR 6 \- read only
+.BR 7 \- offline
+.BR 0x10 \- reset
+.BR 0x11 \- non sequential
+.BR 0x3f \- non write pointer zones
+.TP
+.BR \-v , " \-\-verbose"
+Display the aligned values of
+.I offset
+and
+.IR length .
+.TP
+.BR \-V , " \-\-version"
+Display version information and exit.
+.TP
+.BR \-h , " \-\-help"
+Display help text and exit.
+.SH AUTHOR
+.MT shaun.tancheff@seagate.com
+Shaun Tancheff
+.ME
+.SH SEE ALSO
+.BR sg_rep_zones (8)
+.SH AVAILABILITY
+The blkreport command is part of the util-linux package and is available
+.UR ftp://\:ftp.kernel.org\:/pub\:/linux\:/utils\:/util-linux/
+Linux Kernel Archive
+.UE .
diff --git a/sys-utils/blkreport.c b/sys-utils/blkreport.c
new file mode 100644
index 0000000..de85b9c
--- /dev/null
+++ b/sys-utils/blkreport.c
@@ -0,0 +1,543 @@
+/*
+ * blkreport.c -- request a zone report on part (or all) of the block device.
+ *
+ * Copyright (C) 2015 Seagate Technology PLC
+ * Written by Shaun Tancheff <shaun.tancheff@seagate.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * This program uses BLKREPORT ioctl to query zone information about part of
+ * or a whole block device, if the device supports it.
+ * You can specify range (start and length) to be queried.
+ */
+
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <getopt.h>
+#include <time.h>
+
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <linux/fs.h>
+
+#ifdef HAVE_BLKZONED_API_H
+#include <linux/blkzoned_api.h>
+#endif
+
+#include "nls.h"
+#include "strutils.h"
+#include "c.h"
+
+#ifndef HAVE_BLKZONED_API_H
+/**
+ * enum zone_report_option - Report Zones types to be included.
+ *
+ * @ZOPT_NON_SEQ_AND_RESET: Default (all zones).
+ * @ZOPT_ZC1_EMPTY: Zones which are empty.
+ * @ZOPT_ZC2_OPEN_IMPLICIT: Zones open but not explicitly opened
+ * @ZOPT_ZC3_OPEN_EXPLICIT: Zones opened explicitly
+ * @ZOPT_ZC4_CLOSED: Zones closed for writing.
+ * @ZOPT_ZC5_FULL: Zones that are full.
+ * @ZOPT_ZC6_READ_ONLY: Zones that are read-only
+ * @ZOPT_ZC7_OFFLINE: Zones that are offline
+ * @ZOPT_RESET: Zones that are empty
+ * @ZOPT_NON_SEQ: Zones that have cache writes pending
+ * @ZOPT_NON_WP_ZONES: Zones that do not have Write Pointers (conventional)
+ *
+ * @ZOPT_USE_ATA_PASS: Flag used in kernel to service command I/O
+ *
+ * Used by Report Zones in bdev_zone_get_report: report_option
+ */
+enum zone_report_option {
+	ZOPT_NON_SEQ_AND_RESET   = 0x00,
+	ZOPT_ZC1_EMPTY,
+	ZOPT_ZC2_OPEN_IMPLICIT,
+	ZOPT_ZC3_OPEN_EXPLICIT,
+	ZOPT_ZC4_CLOSED,
+	ZOPT_ZC5_FULL,
+	ZOPT_ZC6_READ_ONLY,
+	ZOPT_ZC7_OFFLINE,
+	ZOPT_RESET               = 0x10,
+	ZOPT_NON_SEQ             = 0x11,
+	ZOPT_NON_WP_ZONES        = 0x3f,
+	ZOPT_USE_ATA_PASS        = 0x80,
+};
+
+/**
+ * enum bdev_zone_type - Type of zone in descriptor
+ *
+ * @ZTYP_RESERVED: Reserved
+ * @ZTYP_CONVENTIONAL: Conventional random write zone (No Write Pointer)
+ * @ZTYP_SEQ_WRITE_REQUIRED: Non-sequential writes are rejected.
+ * @ZTYP_SEQ_WRITE_PREFERRED: Non-sequential writes allowed but discouraged.
+ *
+ * Returned from Report Zones. See bdev_zone_descriptor* type.
+ */
+enum bdev_zone_type {
+	ZTYP_RESERVED            = 0,
+	ZTYP_CONVENTIONAL        = 1,
+	ZTYP_SEQ_WRITE_REQUIRED  = 2,
+	ZTYP_SEQ_WRITE_PREFERRED = 3,
+};
+
+
+/**
+ * enum bdev_zone_condition - Condition of zone in descriptor
+ *
+ * @ZCOND_CONVENTIONAL: N/A
+ * @ZCOND_ZC1_EMPTY: Empty
+ * @ZCOND_ZC2_OPEN_IMPLICIT: Opened via write to zone.
+ * @ZCOND_ZC3_OPEN_EXPLICIT: Opened via open zone command.
+ * @ZCOND_ZC4_CLOSED: Closed
+ * @ZCOND_ZC6_READ_ONLY:
+ * @ZCOND_ZC5_FULL: No remaining space in zone.
+ * @ZCOND_ZC7_OFFLINE: Offline
+ *
+ * Returned from Report Zones. See bdev_zone_descriptor* flags.
+ */
+enum bdev_zone_condition {
+	ZCOND_CONVENTIONAL       = 0,
+	ZCOND_ZC1_EMPTY          = 1,
+	ZCOND_ZC2_OPEN_IMPLICIT  = 2,
+	ZCOND_ZC3_OPEN_EXPLICIT  = 3,
+	ZCOND_ZC4_CLOSED         = 4,
+	/* 0x5 to 0xC are reserved */
+	ZCOND_ZC6_READ_ONLY      = 0xd,
+	ZCOND_ZC5_FULL           = 0xe,
+	ZCOND_ZC7_OFFLINE        = 0xf,
+};
+
+
+/**
+ * enum bdev_zone_same - Report Zones same code.
+ *
+ * @ZS_ALL_DIFFERENT: All zones differ in type and size.
+ * @ZS_ALL_SAME: All zones are the same size and type.
+ * @ZS_LAST_DIFFERS: All zones are the same size and type except the last zone.
+ * @ZS_SAME_LEN_DIFF_TYPES: All zones are the same length but types differ.
+ *
+ * Returned from Report Zones. See bdev_zone_report* same_field.
+ */
+enum bdev_zone_same {
+	ZS_ALL_DIFFERENT        = 0,
+	ZS_ALL_SAME             = 1,
+	ZS_LAST_DIFFERS         = 2,
+	ZS_SAME_LEN_DIFF_TYPES  = 3,
+};
+
+
+/**
+ * struct bdev_zone_get_report - ioctl: Report Zones request
+ *
+ * @zone_locator_lba: starting lba for first [reported] zone
+ * @return_page_count: number of *bytes* allocated for result
+ * @report_option: see: zone_report_option enum
+ *
+ * Used to issue report zones command to connected device
+ */
+struct bdev_zone_get_report {
+	__u64 zone_locator_lba;
+	__u32 return_page_count;
+	__u8  report_option;
+} __attribute__((packed));
+
+/**
+ * struct bdev_zone_descriptor_le - See: bdev_zone_descriptor
+ */
+struct bdev_zone_descriptor_le {
+	__u8 type;
+	__u8 flags;
+	__u8 reserved1[6];
+	__le64 length;
+	__le64 lba_start;
+	__le64 lba_wptr;
+	__u8 reserved[32];
+} __attribute__((packed));
+
+
+/**
+ * struct bdev_zone_report_le - See: bdev_zone_report
+ */
+struct bdev_zone_report_le {
+	__le32 descriptor_count;
+	__u8 same_field;
+	__u8 reserved1[3];
+	__le64 maximum_lba;
+	__u8 reserved2[48];
+	struct bdev_zone_descriptor_le descriptors[0];
+} __attribute__((packed));
+
+
+/**
+ * struct bdev_zone_descriptor - A Zone descriptor entry from report zones
+ *
+ * @type: see zone_type enum
+ * @flags: Bits 0:reset, 1:non-seq, 2-3: resv, 4-7: see zone_condition enum
+ * @reserved1: padding
+ * @length: length of zone in sectors
+ * @lba_start: lba where the zone starts.
+ * @lba_wptr: lba of the current write pointer.
+ * @reserved: padding
+ *
+ */
+struct bdev_zone_descriptor {
+	__u8 type;
+	__u8 flags;
+	__u8  reserved1[6];
+	__be64 length;
+	__be64 lba_start;
+	__be64 lba_wptr;
+	__u8 reserved[32];
+} __attribute__((packed));
+
+
+/**
+ * struct bdev_zone_report - Report Zones result
+ *
+ * @descriptor_count: Number of descriptor entries that follow
+ * @same_field: bits 0-3: enum zone_same (MASK: 0x0F)
+ * @reserved1: padding
+ * @maximum_lba: LBA of the last logical sector on the device, inclusive
+ *               of all logical sectors in all zones.
+ * @reserved2: padding
+ * @descriptors: array of descriptors follows.
+ */
+struct bdev_zone_report {
+	__be32 descriptor_count;
+	__u8 same_field;
+	__u8 reserved1[3];
+	__be64 maximum_lba;
+	__u8 reserved2[48];
+	struct bdev_zone_descriptor descriptors[0];
+} __attribute__((packed));
+
+
+/**
+ * struct bdev_zone_report_io - Report Zones ioctl argument.
+ *
+ * @in: Report Zones inputs
+ * @out: Report Zones output
+ */
+struct bdev_zone_report_io {
+	union {
+		struct bdev_zone_get_report in;
+		struct bdev_zone_report out;
+	} data;
+} __attribute__((packed));
+
+#endif
+
+#ifndef BLKREPORT
+# define BLKREPORT	_IOWR(0x12, 130, struct bdev_zone_report_io)
+#endif
+
+static const char * same_text[] = {
+	"all zones are different",
+	"all zones are same size",
+	"last zone differs by size",
+	"all zones same size - different types",
+};
+
+static const char * type_text[] = {
+	"RESERVED",
+	"CONVENTIONAL",
+	"SEQ_WRITE_REQUIRED",
+	"SEQ_WRITE_PREFERRED",
+};
+
+#define ARRAY_COUNT(x) (sizeof((x))/sizeof((*x)))
+
+int fix_endian = 0;
+
+static inline uint64_t endian64(uint64_t in)
+{
+	return fix_endian ? be64toh(in) : in;
+}
+
+static inline uint32_t endian32(uint32_t in)
+{
+	return fix_endian ? be32toh(in) : in;
+}
+
+static inline uint16_t endian16(uint16_t in)
+{
+	return fix_endian ? be16toh(in) : in;
+}
+
+static void test_endian(struct bdev_zone_report * info)
+{
+	struct bdev_zone_descriptor * entry = &info->descriptors[0];
+	uint64_t be_len;
+	be_len = be64toh(entry->length);
+	if ( be_len == 0x080000 ||
+             be_len == 0x100000 ||
+             be_len == 0x200000 ||
+             be_len == 0x300000 ||
+             be_len == 0x400000 ||
+             be_len == 0x800000 ) {
+		fprintf(stdout, "*** RESULTS are BIG ENDIAN ****\n");
+		fix_endian = 1;
+	} else {
+		fprintf(stdout, "*** RESULTS are LITTLE ENDIAN ****\n");
+	}
+}
+
+const char * condition_str[] = {
+	"cv", /* conventional zone */
+	"e0", /* empty */
+	"Oi", /* open implicit */
+	"Oe", /* open explicit */
+	"Cl", /* closed */
+	"x5", "x6", "x7", "x8", "x9", "xA", "xB", /* xN: reserved */
+	"ro", /* read only */
+	"fu", /* full */
+	"OL"  /* offline */
+	};
+
+static const char * zone_condition_str(uint8_t cond)
+{
+	return condition_str[cond & 0x0f];
+}
+
+static void print_zones(struct bdev_zone_report * info, uint32_t size)
+{
+	uint32_t count = endian32(info->descriptor_count);
+	uint32_t max_count;
+	uint32_t iter;
+	int same_code = info->same_field & 0x0f;
+
+	fprintf(stdout, "  count: %u, same %u (%s), max_lba %lu\n",
+		count,
+		same_code, same_text[same_code],
+		endian64(info->maximum_lba & (~0ul >> 16)) );
+
+	max_count = (size - sizeof(struct bdev_zone_report))
+                        / sizeof(struct bdev_zone_descriptor);
+	if (count > max_count) {
+		fprintf(stdout, "Truncating report to %d of %d zones.\n",
+			max_count, count );
+		count = max_count;
+	}
+
+	for (iter = 0; iter < count; iter++ ) {
+		struct bdev_zone_descriptor * entry = &info->descriptors[iter];
+		unsigned int type  = entry->type & 0xF;
+		unsigned int flags = entry->flags;
+		uint64_t start = endian64(entry->lba_start);
+		uint64_t wp = endian64(entry->lba_wptr);
+		uint8_t cond = (flags & 0xF0) >> 4;
+		uint64_t len = endian64(entry->length);
+
+		if (!len) {
+			break;
+		}
+		fprintf(stdout,
+			"  start: %9lx, len %7lx, wptr %8lx"
+                        " reset:%u non-seq:%u, zcond:%2u(%s) [type: %u(%s)]\n",
+		start, len, wp - start, flags & 0x01, (flags & 0x02) >> 1,
+		cond, zone_condition_str(cond), type, type_text[type]);
+	}
+}
+
+static inline int is_report_option_valid(uint64_t ropt)
+{
+	return (ropt <= ZOPT_ZC7_OFFLINE || ropt == ZOPT_RESET ||
+		ropt == ZOPT_NON_SEQ || ropt == ZOPT_NON_WP_ZONES);
+}
+
+static int do_report(int fd, uint64_t lba, uint64_t len, uint8_t ropt, int do_ata, int verbose)
+{
+	int rc = -4;
+	struct bdev_zone_report_io * zone_info;
+
+	zone_info = malloc(len);
+	if (zone_info) {
+		memset(zone_info, 0, len);
+		zone_info->data.in.report_option     = ropt;
+		zone_info->data.in.return_page_count = len;
+		zone_info->data.in.zone_locator_lba  = lba;
+
+		if (do_ata) {
+			zone_info->data.in.report_option |= 0x80;
+		}
+
+		rc = ioctl(fd, BLKREPORT, zone_info);
+		if (rc != -1) {
+			test_endian(&zone_info->data.out);
+
+			if (verbose)
+				fprintf(stdout, "Found %d zones\n",
+					endian32(zone_info->data.out.descriptor_count));
+
+			print_zones(&zone_info->data.out, len);
+		} else {
+			fprintf(stderr, "ERR: %d -> %s\n\n", errno, strerror(errno));
+		}
+	}
+
+	return rc;
+}
+
+static void __attribute__((__noreturn__)) usage(FILE *out)
+{
+	fputs(USAGE_HEADER, out);
+	fprintf(out,
+	      _(" %s [options] <device>\n"), program_invocation_short_name);
+
+	fputs(USAGE_SEPARATOR, out);
+	fputs(_("Discard the content of sectors on a device.\n"), out);
+
+	fputs(USAGE_OPTIONS, out);
+	fputs(_(" -o, --offset <num>  offset in bytes to report from\n"
+		" -l, --length <num>  length of report (512 bytes to 512k bytes)\n"
+		" -r, --option <report> report option\n"
+		"    report is the numeric value from \"enum zone_report_option\".\n"
+		"             0 - non seq. and reset (default)\n"
+		"             1 - empty\n"
+		"             2 - open implicit\n"
+		"             3 - open explicit\n"
+		"             4 - closed\n"
+		"             5 - full\n"
+		"             6 - read only\n"
+		"             7 - offline\n"
+		"          0x10 - reset\n"
+		"          0x11 - non sequential\n"
+		"          0x3f - non write pointer zones\n"
+		" -a, --ata use ATA passthrough to workaround FW in old SAS HBAs\n"
+		" -v, --verbose       print aligned length and offset\n"),
+		out);
+	fputs(USAGE_SEPARATOR, out);
+	fputs(USAGE_HELP, out);
+	fputs(USAGE_VERSION, out);
+	fprintf(out, USAGE_MAN_TAIL("blkreport(8)"));
+	exit(out == stderr ? EXIT_FAILURE : EXIT_SUCCESS);
+}
+
+
+#define MAX_REPORT_LEN (1 << 19) /* 512k */
+
+int main(int argc, char **argv)
+{
+	char *path;
+	int c;
+	int fd;
+	int secsize;
+	uint64_t blksize;
+	struct stat sb;
+	int verbose = 0;
+	uint64_t ropt = ZOPT_NON_SEQ_AND_RESET;
+	uint64_t offset = 0ul;
+	uint32_t length = MAX_REPORT_LEN;
+	int ata = 0;
+
+	static const struct option longopts[] = {
+	    { "help",      0, 0, 'h' },
+	    { "version",   0, 0, 'V' },
+	    { "offset",    1, 0, 'o' }, /* starting LBA */
+	    { "length",    1, 0, 'l' }, /* max #of bytes for result */
+	    { "ata",       1, 0, 'a' }, /* use ATA passthrough */
+	    { "option",    1, 0, 'r' }, /* report option */
+	    { "verbose",   0, 0, 'v' },
+	    { NULL,        0, 0, 0 }
+	};
+
+	setlocale(LC_ALL, "");
+	bindtextdomain(PACKAGE, LOCALEDIR);
+	textdomain(PACKAGE);
+
+	while ((c = getopt_long(argc, argv, "hVsvo:l:r:a", longopts, NULL)) != -1) {
+		switch(c) {
+		case 'h':
+			usage(stdout);
+			break;
+		case 'V':
+			printf(UTIL_LINUX_VERSION);
+			return EXIT_SUCCESS;
+		case 'l':
+			length = strtou64_or_error(optarg,
+					_("failed to parse length"));
+			break;
+		case 'o':
+			offset = strtou64_or_error(optarg,
+					_("failed to parse offset"));
+			break;
+		case 'r':
+			ropt = strtou64_base_or_err(0, optarg,
+					_("failed to parse report option"));
+			break;
+		case 'a':
+			ata = 1;
+		case 'v':
+			verbose = 1;
+			break;
+		default:
+			usage(stderr);
+			break;
+		}
+	}
+
+	if (optind == argc)
+		errx(EXIT_FAILURE, _("no device specified"));
+
+	path = argv[optind++];
+
+	if (optind != argc) {
+		warnx(_("unexpected number of arguments"));
+		usage(stderr);
+	}
+
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		err(EXIT_FAILURE, _("cannot open %s"), path);
+
+	if (fstat(fd, &sb) == -1)
+		err(EXIT_FAILURE, _("stat of %s failed"), path);
+	if (!S_ISBLK(sb.st_mode))
+		errx(EXIT_FAILURE, _("%s: not a block device"), path);
+
+	if (ioctl(fd, BLKGETSIZE64, &blksize))
+		err(EXIT_FAILURE, _("%s: BLKGETSIZE64 ioctl failed"), path);
+	if (ioctl(fd, BLKSSZGET, &secsize))
+		err(EXIT_FAILURE, _("%s: BLKSSZGET ioctl failed"), path);
+
+	/* check offset alignment to the sector size */
+	if (offset % secsize)
+		errx(EXIT_FAILURE, _("%s: offset %" PRIu64 " is not aligned "
+			 "to sector size %i"), path, offset, secsize);
+
+	/* is the range end behind the end of the device ?*/
+	if (offset > blksize)
+		errx(EXIT_FAILURE, _("%s: offset is greater than device size"), path);
+
+	length = (length / 512) * 512;
+	if (length < 512)
+		length = 512;
+	if (length > MAX_REPORT_LEN)
+		length = MAX_REPORT_LEN;
+
+	if (!is_report_option_valid(ropt))
+		errx(EXIT_FAILURE, _("%s: invalid report option for device"), path);
+
+	if (do_report(fd, offset, length, ropt & 0xFF, ata, verbose))
+		 err(EXIT_FAILURE, _("%s: BLKREPORT ioctl failed"), path);
+
+	close(fd);
+	return EXIT_SUCCESS;
+}
diff --git a/sys-utils/blkzonecmd.8 b/sys-utils/blkzonecmd.8
new file mode 100644
index 0000000..6aef31a
--- /dev/null
+++ b/sys-utils/blkzonecmd.8
@@ -0,0 +1,78 @@
+.TH BLKZONECMD 5 "March 2016" "util-linux" "System Administration"
+.SH NAME
+blkzonecmd \- report zones on a device
+.SH SYNOPSIS
+.B blkzonecmd
+[options]
+.RB [ \-z
+.IR zone ]
+.I [\-o] or [\-c] or [\-r]
+.I device
+.SH DESCRIPTION
+.B blkzonecmd
+is used to modify the state of a zone.  This is useful for
+zoned devices that support the ZAC or ZBC command set.
+Unlike
+.BR sg_zone (8) ,
+this command is can be used on any block device.
+.PP
+By default,
+.B blkzonecmd
+will open the zone at the start of the block device. Options may be used to
+modify this behavior based on the starting zone or size of the report,
+as explained below.
+.PP
+The
+.I device
+argument is the pathname of the block device.
+.PP
+.SH OPTIONS
+The
+.I zone
+argument may be followed by the multiplicative suffixes KiB (=1024),
+MiB (=1024*1024), and so on for GiB, TiB, PiB, EiB, ZiB and YiB (the "iB" is
+optional, e.g., "K" has the same meaning as "KiB") or the suffixes
+KB (=1000), MB (=1000*1000), and so on for GB, TB, PB, EB, ZB and YB.
+.TP
+.BR \-z , " \-\-zone \fIoffset"
+Byte offset into the device on which to perform the zone command.
+The provided value will be aligned to the device sector size.
+The default value is zero.
+.TP
+.BR \-o , " \-\-open"
+Send an Open Zone command.
+.TP
+.BR \-c , " \-\-close"
+Send an Close Zone command.
+.TP
+.BR \-r , " \-\-reset"
+Send a Reset Zone command. On success all data in the zone will be
+deleted.
+.TP
+.BR \-a , " \-\-ata"
+Issue ATA passthrough commands to the connected device. This option is to
+enable retrieving zone reports from SATA devices connected via SAS HBA's
+which have old firmware and will not translate ZBC commands to ZAC commands
+internally.
+.B blkzonecmd.
+.TP
+.BR \-v , " \-\-verbose"
+Display the aligned values of
+.I zone
+.TP
+.BR \-V , " \-\-version"
+Display version information and exit.
+.TP
+.BR \-h , " \-\-help"
+Display help text and exit.
+.SH AUTHOR
+.MT shaun.tancheff@seagate.com
+Shaun Tancheff
+.ME
+.SH SEE ALSO
+.BR sg_zone (8)
+.SH AVAILABILITY
+The blkzonecmd command is part of the util-linux package and is available
+.UR ftp://\:ftp.kernel.org\:/pub\:/linux\:/utils\:/util-linux/
+Linux Kernel Archive
+.UE .
diff --git a/sys-utils/blkzonecmd.c b/sys-utils/blkzonecmd.c
new file mode 100644
index 0000000..6351be6
--- /dev/null
+++ b/sys-utils/blkzonecmd.c
@@ -0,0 +1,239 @@
+/*
+ * blkreport.c -- request a zone report on part (or all) of the block device.
+ *
+ * Copyright (C) 2015 Seagate Technology PLC
+ * Written by Shaun Tancheff <shaun.tancheff@seagate.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * This program uses BLKREPORT ioctl to query zone information about part of
+ * or a whole block device, if the device supports it.
+ * You can specify range (start and length) to be queried.
+ */
+
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <getopt.h>
+#include <time.h>
+
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <linux/fs.h>
+
+#ifdef HAVE_BLKZONED_API_H
+#include <linux/blkzoned_api.h>
+#endif
+
+#include "nls.h"
+#include "strutils.h"
+#include "c.h"
+
+#ifndef BLKDISCARD
+# define BLKDISCARD	_IO(0x12,119)
+#endif
+
+#ifndef BLKOPENZONE
+# define BLKOPENZONE	_IO(0x12, 131)
+#endif
+
+#ifndef BLKCLOSEZONE
+# define BLKCLOSEZONE	_IO(0x12, 132)
+#endif
+
+enum {
+	ACT_OPEN_ZONE = 0,
+	ACT_CLOSE_ZONE,
+	ACT_RESET_ZONE,
+};
+
+static void print_stats(int act, char *path, uint64_t lba)
+{
+	switch (act) {
+	case ACT_RESET_ZONE:
+		printf(_("%s: Reset Zone %" PRIu64 "\n"), path, lba);
+		break;
+	case ACT_OPEN_ZONE:
+		printf(_("%s: Open Zone %" PRIu64 "\n"), path, lba);
+		break;
+	case ACT_CLOSE_ZONE:
+		printf(_("%s: Close Zone %" PRIu64 "\n"), path, lba);
+		break;
+	default:
+		printf(_("%s: Unknown Action on %" PRIu64 "\n"), path, lba);
+		break;
+	}
+}
+
+#define DEFAULT_ZONE_ORDER (19 + 9)
+
+static inline int issue_discard(int fd, uint64_t zone_lba, uint64_t ata)
+{
+	uint64_t range[2] = { zone_lba, 1 << DEFAULT_ZONE_ORDER };
+
+	return ioctl(fd, BLKDISCARD, &range);
+}
+
+static void __attribute__((__noreturn__)) usage(FILE *out)
+{
+	fputs(USAGE_HEADER, out);
+	fprintf(out,
+	      _(" %s [options] <device>\n"), program_invocation_short_name);
+
+	fputs(USAGE_SEPARATOR, out);
+	fputs(_("Discard the content of sectors on a device.\n"), out);
+
+	fputs(USAGE_OPTIONS, out);
+	fputs(_(" -z, --zone <num>    lba of start of zone to act upon\n"
+		" -o, --open          open zone\n"
+		" -c, --close         close zone\n"
+		" -r, --reset         reset zone\n"
+		" -a, --ata           use ata passthrough\n"
+		" -v, --verbose       print aligned length and offset\n"),
+		out);
+	fputs(USAGE_SEPARATOR, out);
+	fputs(USAGE_HELP, out);
+	fputs(USAGE_VERSION, out);
+	fprintf(out, USAGE_MAN_TAIL("blkzonecmd(8)"));
+	exit(out == stderr ? EXIT_FAILURE : EXIT_SUCCESS);
+}
+
+
+int main(int argc, char **argv)
+{
+	char *path;
+	int c, fd, verbose = 0, secsize;
+	uint64_t blksize;
+	struct stat sb;
+	uint64_t zone_lba = 0ul;
+	int ata = 0;
+	int act = ACT_OPEN_ZONE;
+
+	static const struct option longopts[] = {
+	    { "help",      0, 0, 'h' },
+	    { "version",   0, 0, 'V' },
+	    { "zone",      1, 0, 'z' },
+	    { "open",      0, 0, 'o' },
+	    { "close",     0, 0, 'c' },
+	    { "reset",     0, 0, 'r' },
+	    { "ata",       0, 0, 'a' },
+	    { "verbose",   0, 0, 'v' },
+	    { NULL,        0, 0, 0 }
+	};
+
+	setlocale(LC_ALL, "");
+	bindtextdomain(PACKAGE, LOCALEDIR);
+	textdomain(PACKAGE);
+
+	zone_lba = 0;
+
+	while ((c = getopt_long(argc, argv, "hVaocrz:", longopts, NULL)) != -1) {
+		switch(c) {
+		case 'h':
+			usage(stdout);
+			break;
+		case 'V':
+			printf(UTIL_LINUX_VERSION);
+			return EXIT_SUCCESS;
+		case 'z':
+			zone_lba = strtou64_or_error(optarg,
+					_("failed to parse length"));
+			break;
+		case 'a':
+			ata = 1;
+			break;
+		case 'o':
+			act = ACT_OPEN_ZONE;
+			break;
+		case 'c':
+			act = ACT_CLOSE_ZONE;
+			break;
+		case 'r':
+			act = ACT_RESET_ZONE;
+			break;
+		case 'v':
+			verbose = 1;
+			break;
+		default:
+			usage(stderr);
+			break;
+		}
+	}
+
+	if (optind == argc)
+		errx(EXIT_FAILURE, _("no device specified"));
+
+	path = argv[optind++];
+
+	if (optind != argc) {
+		warnx(_("unexpected number of arguments"));
+		usage(stderr);
+	}
+
+	fd = open(path, O_WRONLY);
+	if (fd < 0)
+		err(EXIT_FAILURE, _("cannot open %s"), path);
+
+	if (fstat(fd, &sb) == -1)
+		err(EXIT_FAILURE, _("stat of %s failed"), path);
+	if (!S_ISBLK(sb.st_mode))
+		errx(EXIT_FAILURE, _("%s: not a block device"), path);
+
+	if (ioctl(fd, BLKGETSIZE64, &blksize))
+		err(EXIT_FAILURE, _("%s: BLKGETSIZE64 ioctl failed"), path);
+	if (ioctl(fd, BLKSSZGET, &secsize))
+		err(EXIT_FAILURE, _("%s: BLKSSZGET ioctl failed"), path);
+
+	/* check offset alignment to the sector size */
+	if (zone_lba % secsize)
+		errx(EXIT_FAILURE, _("%s: offset %" PRIu64 " is not aligned "
+			 "to sector size %i"), path, zone_lba, secsize);
+
+	/* is the range end behind the end of the device ?*/
+	if (zone_lba > blksize)
+		errx(EXIT_FAILURE, _("%s: offset is greater than device size"), path);
+
+	if (ata) {
+		zone_lba |= 1ul; /* ensure low bit is set */
+	} else {
+		zone_lba &= ~1ul; /* ensure low bit is clear */
+	}
+
+	switch (act) {
+	case ACT_OPEN_ZONE:
+		if (ioctl(fd, BLKOPENZONE, zone_lba))
+			 err(EXIT_FAILURE, _("%s: BLKOPENZONE ioctl failed"), path);
+		break;
+	case ACT_CLOSE_ZONE:
+		if (ioctl(fd, ACT_CLOSE_ZONE, zone_lba))
+			err(EXIT_FAILURE, _("%s: BLKSECDISCARD ioctl failed"), path);
+		break;
+
+	case ACT_RESET_ZONE:
+		if (issue_discard(fd, zone_lba, ata))
+			err(EXIT_FAILURE, _("%s: BLKDISCARD ioctl failed"), path);
+		break;
+	}
+
+	if (verbose && zone_lba)
+		print_stats(act, path, zone_lba);
+
+	close(fd);
+	return EXIT_SUCCESS;
+}
